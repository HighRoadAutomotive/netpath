using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Threading;
using NETPath.Generators.Interfaces;
using NETPath.Projects;
using NETPath.Projects.Helpers;

namespace NETPath.Generators.CS
{
	public class Generator : IGenerator
	{
		public Action<Guid, string> NewOutput { get; private set; }
		public Action<Guid, CompileMessage> NewMessage { get; private set; }
		public ObservableCollection<CompileMessage> Messages { get; private set; }
		public CompileMessageSeverity HighestSeverity { get; private set; }
		public string Name { get; private set; }
		public GenerationLanguage Language { get; private set; }
		public GenerationModule Module { get; private set; }
		public bool IsInitialized { get; private set; }

		public Generator()
		{
			Messages = new ObservableCollection<CompileMessage>();
			Name = "NETPath .NET CSharp Generator";
			Language = GenerationLanguage.CSharp;
			Module = GenerationModule.WindowsRuntime;
		}

		public void Initialize(Action<Guid, string> OutputHandler, Action<Guid, CompileMessage> CompileMessageHandler)
		{
			NewOutput = OutputHandler;
			NewMessage = CompileMessageHandler;
			IsInitialized = true;
		}

		[System.Reflection.Obfuscation(Feature = "encryptmethod", Exclude = false, StripAfterObfuscation = true)]
		public void Build(Project Data, string ProjectPath, bool ClientOnly = false)
		{
			HighestSeverity = CompileMessageSeverity.INFO;
			Messages.Clear();
			NewOutput(Data.ID, Globals.ApplicationTitle);
			NewOutput(Data.ID, string.Format("Version: {0}", Globals.ApplicationVersion));
			NewOutput(Data.ID, "Copyright © 2012-2013 Prospective Software Inc.");

			Verify(Data);

			//If the verification produced errors exit with an error code, we cannot proceed.
			if (HighestSeverity == CompileMessageSeverity.ERROR)
				return;

			Console.WriteLine("Project Path: {0}", ProjectPath);
			string projdir = System.IO.Path.GetDirectoryName(ProjectPath);
			Console.WriteLine("Project Directory: {0}", projdir);

			foreach (ProjectGenerationTarget t in Data.ServerGenerationTargets)
			{
				Console.WriteLine("Output Relative Path: {0}", t.Path);
				string op = System.IO.Path.Combine(projdir, t.Path.Replace("/", "\\"));
				Console.WriteLine("Output Absolute Path: {0}", op);
				NewOutput(Data.ID, string.Format("Writing Server Output: {0}", op));
				System.IO.File.WriteAllText(op, Generate(Data, t, true));
			}

			foreach (ProjectGenerationTarget t in Data.ClientGenerationTargets)
			{
				Console.WriteLine("Output Relative Path: {0}", t.Path);
				string op = System.IO.Path.Combine(projdir, t.Path.Replace("/", "\\"));
				Console.WriteLine("Output Absolute Path: {0}", op);
				op = Uri.UnescapeDataString(op);
				NewOutput(Data.ID, string.Format("Writing Client Output: {0}", op));
				System.IO.File.WriteAllText(op, Generate(Data, t, false));
			}
		}

		public Task BuildAsync(Project Data, string ProjectPath, bool ClientOnly = false)
		{
			return System.Windows.Application.Current == null ? null : Task.Run(() => System.Windows.Application.Current.Dispatcher.Invoke(() => Build(Data, ProjectPath, ClientOnly), DispatcherPriority.Normal));
		}

		[System.Reflection.Obfuscation(Feature = "encryptmethod", Exclude = false, StripAfterObfuscation = true)]
		public void Verify(Project Data)
		{
			NamespaceGenerator.VerifyCode(Data.Namespace, AddMessage);
		}

		public Task VerifyAsync(Project Data)
		{
			return System.Windows.Application.Current == null ? null : Task.Run(() => System.Windows.Application.Current.Dispatcher.Invoke(() => Verify(Data), DispatcherPriority.Normal));
		}

		private string Generate(Project Data, ProjectGenerationTarget Target, bool Server)
		{
			Globals.CurrentProjectID = Data.ID;

			var code = new StringBuilder();
			code.AppendLine("//---------------------------------------------------------------------------");
			code.AppendLine("// This code was generated by a tool. Changes to this file may cause ");
			code.AppendLine("// incorrect behavior and will be lost if the code is regenerated.");
			code.AppendLine("//");
			code.AppendLine(string.Format("// NETPath Version:\t{0}", Globals.ApplicationVersion));
			if (Target.Framework == ProjectGenerationFramework.NET45) code.AppendLine("// .NET Framework Version:\t4.5");
			if (Target.Framework == ProjectGenerationFramework.WIN8) code.AppendLine("// Windows Runtime Version:\t8.0");
			code.AppendLine("//---------------------------------------------------------------------------");
			code.AppendLine();

			// Generate using namespaces
			foreach (ProjectUsingNamespace pun in Data.UsingNamespaces)
			{
				if ((pun.Server && Server) || (pun.Client && !Server && ((pun.RT && Target.Framework == ProjectGenerationFramework.WIN8) || (pun.NET && Target.Framework == ProjectGenerationFramework.NET45))))
					code.AppendLine(string.Format("using {0};", pun.Namespace));
			}
			if (Data.EnableEntityFramework && Server) code.AppendLine("using System.Data.Entity.Core.Objects;");
			code.AppendLine();

			//Generate ContractNamespace Attributes
			if (!Server) code.AppendLine(NamespaceGenerator.GenerateContractNamespaceAttributes(Data.Namespace, Target));

			//Disable XML documentation warnings 
			if (!Data.EnableDocumentationWarnings) code.AppendLine("#pragma warning disable 1591");

			//Generate project
			if (Server)
			{
				if (Target.Framework == ProjectGenerationFramework.NET45 || Target.Framework == ProjectGenerationFramework.WIN8)
					code.AppendLine(NamespaceGenerator.GenerateServerCode45(Data.Namespace, Target));
			}
			else
			{
				if (Target.Framework == ProjectGenerationFramework.NET45) code.AppendLine(NamespaceGenerator.GenerateClientCode45(Data.Namespace, Target));
				if (Target.Framework == ProjectGenerationFramework.WIN8) code.AppendLine(NamespaceGenerator.GenerateClientCodeRT8(Data.Namespace, Target));
			}

			//Reenable XML documentation warnings
			if (!Data.EnableDocumentationWarnings) code.AppendLine("#pragma warning restore 1591");

			return code.ToString();
		}

		private void AddMessage(CompileMessage Message)
		{
			Messages.Add(Message);
			if (Message.Severity == CompileMessageSeverity.ERROR && HighestSeverity != CompileMessageSeverity.ERROR) HighestSeverity = CompileMessageSeverity.ERROR;
			if (Message.Severity == CompileMessageSeverity.WARN && HighestSeverity == CompileMessageSeverity.INFO) HighestSeverity = CompileMessageSeverity.WARN;
			NewOutput(Message.ProjectID, string.Format("{0} {1}: {2} Object: {3} Owner: {4}", Message.Severity, Message.Code, Message.Description, Message.ErrorObject, Message.Owner));
			NewMessage(Message.ProjectID, Message);
		}
	}

	internal static class Globals
	{
		public static readonly Version ApplicationVersion;
		public const string ApplicationTitle = "NETPath C# Generator";

		public static Guid CurrentProjectID { get; set; }

		static Globals()
		{
			string asmfp = System.IO.Path.GetDirectoryName(new Uri(System.Reflection.Assembly.GetCallingAssembly().CodeBase).LocalPath);
			if (asmfp == null) return;
			ApplicationVersion = new Version(System.Diagnostics.FileVersionInfo.GetVersionInfo(System.IO.Path.Combine(asmfp, "NETPath.Generators.CS.dll")).FileVersion);
		}
	}
}